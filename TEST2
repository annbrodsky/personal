const async = require('async');
const crypto = require('crypto');
const device = require('device');
const jwt = require('jsonwebtoken');
const jwksClient = require('jwks-rsa');
const { promisify } = require('util');
const { default: TokenEase } = require('tokenease');
const { User } = require('./service/user');
const { ROLE_TAG_MAPPING } = require('./constants/users');
const uniqueId = require('./unique_id');
const whitelistedClients = require('./whitelisted_clients');
const buckets = require('./buckets');
const subscribeWithGoogle = require('./swg');
const execEdition = require('./exec_edition');
const { getAuthCookieOptions, isQa, isHarmonyVariant } = require('./util');

const { OIDC_ENABLE } = process.env;

const {
  COOKIE_NAME_ID_TOKEN,
  COOKIE_NAME_REFRESH_TOKEN,
  JWT_DELTAX_MAPPING,
} = require('./constants/oidc_auth');

const {
  BUYSIDE_EXCLUSIVE_ACCESS_ROLES,
  MOBILE_ONLY_ROLES,
  PAUSED_SUB_ROLES,
  ROLE_TO_CRITERIA,
  USER_EXP_MAP,
  USER_TYPE_MAP,
} = require('./constants/users');

const tokenEase = new TokenEase(isQa ? 'dev' : 'prod');

/**
 * Helper to attach entitlement specific values and functions to DeltaX user.
 *
 * NOTE: This should probably be part of the region or user services.
 *
 * @param   {object} region A Region object.
 * @param   {object} user
 *
 * @return  {user}  The modified user object, the same object as the user
 *   parameter.
 */
function extendUser(region, user) {
  user._fullAccess = false;
  user._fullArticle = false;
  user.vetoFree = false;
  user.wsjregion = region.wsjregion;
  user.site = region.site;
  const hashes = _getEmailHashes(user);

  if (hashes) {
    user.emailHashes = hashes;
  }

  user.roles.forEach(function (role) {
    var criteria = ROLE_TO_CRITERIA[role];

    if (criteria && criteria.non_vetoable)
      user._non_vetoable = true;

    if (criteria && criteria.sites) {
      criteria.sites.forEach(function (site) {
        if (region.site === site) {
          user._fullAccess = true;
          user._fullArticle = true;
        }
      });
    } else if (criteria && criteria.article) {
      criteria.article.forEach(function (site) {

        if (site === 'wsjpro') {
          user._allowProArticle = true;
        }

        if (site === 'barronsAdvisor') {
          user._allowAdvisorProArticle = true;
        }

        if (region.site === site) {
          user._fullArticle = true;
        }
      });
    } else if (criteria && criteria.veto_free_assess) {
      criteria.veto_free_assess.forEach(function (site) {
        if (region.site === site) {
          user.vetoFree = true;
        }
      });
    }
  });

  //user.vetoFree is a public property that says that the user should not see the full article even if free.
  if (user.vetoFree && user._fullArticle) {
    user.vetoFree = false; //lower priority than any other role granting access
  }

  user.type = _getType(user, region.site);
  user.experience = _getExp(user);

  return user;
}

/**
 * Helper we expose that allows for creation of a user object from DeltaX data.
 *
 * @param   {object} user
 *
 * @return  {user}  New instance of User populated with data from the generic user parameter object.
 */
function createUserFromData(data) {
  const newUser = new User();
  const newUserPrototype = Object.getPrototypeOf(newUser);

  if (typeof data !== 'object') return newUser;
  // Remove any values in provided data that would conflict with User functions
  for (const key of Object.getOwnPropertyNames(newUserPrototype)) {
    if (typeof newUser[key] === 'function' && data[key]) {
      delete data[key];
    }
  }

  return Object.assign(newUser, data);
}

const ssoPrefix = `https://sso.${isQa ? 'int.' : ''}accounts.dowjones.com`;

const identityClient = jwksClient({
  jwksUri: `${ssoPrefix}/.well-known/jwks.json`
});

const contentAccessClient = jwksClient({
  jwksUri: `https://www.${isQa ? 'dev.' : ''}wsj.com/client/.well-known/jwks.json`
});

const getKey = (issuer) => {
  const client = issuer === 'content-access' ? contentAccessClient : identityClient;
  return (header, callback) => {
    client.getSigningKey(header.kid, function(err, key) {
      const signingKey = key.publicKey || key.rsaPublicKey;
      callback(null, signingKey);
    });
  }
}

const decryptIdentityJwt = async (token) => {
  return await _decryptJwt(token);
};

const decryptIdentityJwtWithNonce = async (token, nonce) => {
  const payload = await _decryptJwt(token);

  if (payload.nonce && payload.nonce !== nonce) {
    const error = new Error('Nonce in JWT does not match cookie');
    error.name = 'NonceMistmatchError';
    throw error;
  }

  return payload;
};

const _decryptJwt = async (token, issuer) => {
  const jwtVerify = promisify(jwt.verify);

  const payload = await jwtVerify(token, getKey(issuer));

  const expiration = payload.exp * 1000;
  if (Date.now() > expiration) {
    const error = new Error('JWT is expired');
    error.name = 'ExpiredError'
    throw error;
  }

  return payload;
};

/**
 * The EntitlementsService uses various other services to decorate the user
 *   returned from the user service with additional roles and fields saying
 *   what the user may access.
 *
 */
function EntitlementsService(userService, openhouse, regionService, metaDataService, loggerService, propSvc, groupCookieSvc, shawshank, cxense, profiles) {
  var ns = 'dj.svc.entitlements.EntitlementsService';
  this.userService = userService;
  this.regionService = regionService;
  this.metaDataService = metaDataService;
  this.logger = loggerService.getLogger(ns);

  this.openhouseEntitlement = openhouse;
  this.shawshankEntitlement = shawshank;
  this.cxenseEntitlement = cxense;
  this.profilesEntitlement = profiles;

  this.properties = propSvc.getProperties(ns);
  this.properties.setMany({
    'oidc_autologin': {
      'development,fdev,sat': {
        'wsj': 'https://www.dev.wsj.com/client/silent-login?target=',
        'barrons': 'https://www.s.dev.barrons.com/client/silent-login?target=',
        'marketwatch': 'https://www.s.dev.marketwatch.com/client/silent-login?target=',
      },
      'all': {
        'wsj': 'https://www.wsj.com/client/silent-login?target=',
        'barrons': 'https://www.barrons.com/client/silent-login?target=',
        'marketwatch': 'https://www.marketwatch.com/client/silent-login?target=',
      }
    },
    'one_id_autologin': {
      'development,fdev,sat': {
        'wsj': 'https://int.accounts.wsj.com/login?target=',
        'barrons': 'https://int.accounts.barrons.com/login?target=',
        'marketwatch': 'https://int.accounts.marketwatch.com/login?target='
      },
      'all': {
        'wsj': 'https://accounts.wsj.com/login?target=',
        'barrons': 'https://accounts.barrons.com/login?target=',
        'marketwatch': 'https://accounts.marketwatch.com/login?target='
      }
    },
    'one_id_autologout': {
      'development,fdev,sat': {
        'wsj': 'https://int.accounts.wsj.com/logout?target=',
        'barrons': 'https://int.accounts.barrons.com/logout?target=',
        'marketwatch': 'https://int.accounts.marketwatch.com/logout?target='
      },
      'all': {
        'wsj': 'https://accounts.wsj.com/logout?target=',
        'barrons': 'https://accounts.barrons.com/logout?target=',
        'marketwatch': 'https://accounts.marketwatch.com/logout?target='
      }
    },
  });

  this._user = null;
  this.groupCookieSvc = groupCookieSvc;
}

EntitlementsService.prototype.connect = function (req, groupCookieSvc, userService) {
  this.req = req;
  this.groupCookieSvc = groupCookieSvc;
  this.userService = userService;
};

EntitlementsService.$inject =
  [
    'dj.svc.entitlements/lib/service/user/user_service',
    'dj.svc.entitlements.openhouse',
    'dj.svc.region.RegionService',
    'dj.svc.meta.MetaDataService',
    'core.LoggerService',
    'core.PropertyService',
    'dj.svc.groupCookie.GroupCookieService',
    'dj.svc.entitlements.Shawshank',
    'dj.svc.entitlements.Cxense',
    'dj.svc.entitlements.Profiles'
  ];

EntitlementsService.USER_TYPE_MAP = USER_TYPE_MAP;
EntitlementsService.USER_EXP_MAP = USER_EXP_MAP;
EntitlementsService.ROLE_TO_CRITERIA = ROLE_TO_CRITERIA;

/**
 * A middleware version of the #getUser method. The decorated user is placed on
 * the request object at req.user. A warning is emitted if this
 *
 * Optional plugins parameter. For list of valid plugins refer to "defaultPluginsMapping"
 */
EntitlementsService.prototype.getMiddleware = function (plugins) {
  if (plugins && !Array.isArray(plugins)) {
    throw new Error('Plugins should be an array. For list of valid plugins refer to "defaultPluginsMapping"');
  }

  this.plugins = plugins;
  var self = this;

  return function (req, res, next) {

    if (req.user) return next();

    self.req = req;

    //temporary: new convention is using req.region, depending on regionservice should be deprecated.
    self.region = (self.regionService && self.regionService.region) || (self.req && self.req.region);
    if (!self.region) {
      throw new Error('Region middleware must be called before entitlement middleware');
    }

    const idToken = self.groupCookieSvc.getGroupCookie(COOKIE_NAME_ID_TOKEN);
    const refreshToken = self.groupCookieSvc.getGroupCookie(COOKIE_NAME_REFRESH_TOKEN);

    const oidcEnabledProducts = (OIDC_ENABLE && OIDC_ENABLE.split(',')) || [];
    const useJwt = OIDC_ENABLE === 'true' || oidcEnabledProducts.includes(self.region.site);

    if (idToken && useJwt) {
      return self._handleJwtUser(idToken, refreshToken, req, res, next);
    } else if (refreshToken && useJwt) {
      return self._refreshTokenRedirect(req, res);
    }

    self._getUser(req, self.region, function (err, data) {
      if (err) {
        self.logger.warn(err);
      }

      const userInfo = data || new User();

      if (userInfo?.status === 'user_has_autologin') {
        const nonPlsUser = userInfo.autologin_info?.issuer?.startsWith('https://sso.');
        return res.redirect(302, self._getAutoLoginURL(req, self.region.site, nonPlsUser));
      }

      if (userInfo?.status === 'user_logged_out') {
        return res.redirect(302, self._getAutoLogoutURL(req, self.region.site));
      }

      self._buildUser(userInfo, req, self.region, res, function (err, user) {
        req.user = user;
        next(err);
      });
    });
  };
};

EntitlementsService.prototype._getAutoLoginURL = function (req, site, nonPlsUser) {
  // hack as temp fix to entitlements call as service
  const refreshURL = process.env.OVERRIDE_REFRESH_URL; // hack to temproily fix service calls to auth

  const target = refreshURL || getTargetUrlFromReq(req);

  // Standard users should use new OIDC autologin endpoint to get OIDC cookies.
  // Not yet supported for PLS users
  const oidcMigratedSites = ['barrons', 'wsj'];
  const siteIsBeingMigrated = oidcMigratedSites.includes(site);

  const key = nonPlsUser && siteIsBeingMigrated ? 'oidc_autologin' : 'one_id_autologin';
  const loginMap = this.properties.get(key);

  return `${loginMap[site] || loginMap.wsj}${encodeURIComponent(target)}`;
};

EntitlementsService.prototype._getAutoLogoutURL = function (req, site) {
  const target = getTargetUrlFromReq(req);
  const loginMap = this.properties.get('one_id_autologout');

  return `${loginMap[site] || loginMap.wsj}${encodeURIComponent(target)}`;
};

/**
 * Allows use of the entitlements service as an app-wide middleware.
 *
 */
EntitlementsService.prototype.handle = function (req, res, next) {
  this.getMiddleware()(req, res, next);
};

// Makes #user a getter in order to provide logging on invalid uses.
Object.defineProperty(EntitlementsService.prototype, 'user', {
  /**
   * Returns the user if the middleware has run. If it hasn't, returns
   * undefined and logs an error.
   */
  get: function () {
    if (this._user) {
      return this._user;
    }
    this.logger.error('EntitlementsService middleware must be in place before ' +
      'accessing the user. Returning a default user.');
    return extendUser(this.region || {}, new User());
  }
});

/**
 * Leave empty function as it is called by apps. Will remove with new entitlements platform
 */
EntitlementsService.prototype.requestAccessPaidArticle = function () {
};

/**
 * Gets the decorated user. This is only called by the middleware function,
 * once per lifetime of the EntitlementsService object.
 */
EntitlementsService.prototype._getUser = function (req, region, cb) {
  var self = this;

  self.userService.get(function (err, user) {
    if (err) {
      self.logger.warn('User service error detected. Using default user. %j', err);
    }

    cb(null, user);
  });
};

/** Build a user object from the user information returned from user service.*/
EntitlementsService.prototype._buildUser = function (userInfo, req, region, res, cb) {
  // If we have a wsj user that has a mobile only subscription but is
  // viewing this page in the in-app web view or on a mobile device, we treat
  // them as a regular subscriber. We know they are in a web view because of the query param
  const NATIVE_QUERY_PARAMS = [
    'iphone',
    'ipad',
    'android',
    'androidphone',
    'androidtablet'
  ];

  if ((region.site === 'wsj') && !userInfo.roles.includes('WSJ') && userInfo.hasSomeRoles(MOBILE_ONLY_ROLES.wsj)) {
    const userAgent = req.headers && req.headers['user-agent'];
    const deviceType = device(userAgent, { unknownUserAgentDeviceType: 'desktop' });
    const hasQueryParam = NATIVE_QUERY_PARAMS.includes(req.query.wsj_native_webview);
    const isMobileDevice = ['phone', 'tablet'].includes(deviceType.type);

    if (hasQueryParam || isMobileDevice) {
      userInfo.roles.push('WSJ');
    }
  }

  if (PAUSED_SUB_ROLES[region.site] && userInfo.roles.includes(PAUSED_SUB_ROLES[region.site])) {
    userInfo.pausedSub = true;
  }

  if (userInfo.hasSomeRoles(BUYSIDE_EXCLUSIVE_ACCESS_ROLES)) {
    userInfo.buysideExclusiveAccess = true;
  }

  this._applyEntitlements(userInfo, region, req, res, (err) => {
    if (err) {
      this.logger.warn(err);
    }

    this._user = extendUser(region, userInfo);
    this._setMeta(this._user); // updates page meta tags

    if (req.cxense_active) {
      req.internal_paywall = {
        campaign: 1000,
        placement: 'cx-snippetad',
        tag: 'default',
        type: 'personalized',
      };
    }

    isHarmonyVariant(this._user, region.site)

    cb(null, this._user);
  });

};

/**
 * Modifies the user object to reflect various business rules around
 * entitlements.
 *
 * @private
 */
EntitlementsService.prototype._applyEntitlements = function (user, region, req, res, cb) {
  const cxenseDependencies = [
    'openhouse',
    'whitelist',
    'shawshank',
    'buckets',
    'profiles',
  ];

  const defaultPluginsMapping = [
    { name: 'openhouse',          dependencies: null,                       func: this.openhouseEntitlement },
    { name: 'whitelist',          dependencies: null,                       func: whitelistedClients },
    { name: 'shawshank',          dependencies: ['uniqueid'],               func: this.shawshankEntitlement },
    { name: 'buckets',            dependencies: ['uniqueid'],               func: buckets },
    { name: 'profiles',           dependencies: ['whitelist', 'uniqueid'],  func: this.profilesEntitlement },
    { name: 'cxense',             dependencies: cxenseDependencies,         func: this.cxenseEntitlement },
    { name: 'uniqueid',           dependencies: null,                       func: uniqueId },
    { name: 'swg',                dependencies: ['cxense'],                 func: subscribeWithGoogle },
    { name: 'execedition',        dependencies: null,                       func: execEdition }
  ];

  let pluginsMapping = defaultPluginsMapping;
  // if plugins are provided, find the dependencies for each plugin from the default mapping.
  // and construct a new mapping for the specified plugins
  if (this.plugins) {
    pluginsMapping = this._getPluginDependencies(defaultPluginsMapping, this.plugins);
  }

  let redirect;
  const autoTasks = {};

  pluginsMapping.forEach((plugin) => {
    const worker = (callback) => {
      if (redirect) {
        return callback();
      }

      plugin.func.getEntitlement(req, user, region, this.groupCookieSvc, (err, result) => {
        if (err) {
          this.logger.warn(err);
        } else if (result && result.redirect && (typeof result.redirect === 'string')) {
          redirect = result.redirect;
        } else if (result && result.role && (typeof result.role === 'string') && (user.roles.indexOf(result.role) === -1)) {
          user.roles.push(result.role);
        }

        return callback();
      });
    };

    if (!plugin.dependencies) {
      autoTasks[plugin.name] = worker;
    } else {
      plugin.dependencies.push(worker);
      autoTasks[plugin.name] = plugin.dependencies;
    }
  });

  async.auto(autoTasks, (err) => {
    if (redirect) {
      return res.redirect(302, redirect);
    }

    cb(err);
  });
};

// On visiting object, check for its dependencies and visit them recursively
EntitlementsService.prototype._getPluginDependencies = function (defaultPluginsMapping, plugins, pluginsRequested = []) {
  plugins.forEach((plugin) => {
    let obj = defaultPluginsMapping.find(p => p.name === plugin);
    if (!obj) return;
    let visited = pluginsRequested.find(p => p.name === plugin);
    if (!visited) {
      pluginsRequested.push(obj);
      if (obj.dependencies) {
        this._getPluginDependencies(defaultPluginsMapping, obj.dependencies, pluginsRequested);
      }
    }
  });
  return pluginsRequested;
}

EntitlementsService.prototype._handleJwtUser = async function (idToken, refreshToken, req, res, next) {
  let decompressedJwt;
  let jwt;

  try {
    decompressedJwt = tokenEase.decompressJwt(idToken);
    jwt = await _decryptJwt(decompressedJwt, 'content-access');
  } catch (error) {
    if (error.name === 'ExpiredError' && refreshToken) {
      return this._refreshTokenRedirect(req, res);
    }

    const host = getHost(req);
    res.clearCookie(COOKIE_NAME_REFRESH_TOKEN, getAuthCookieOptions({ name: COOKIE_NAME_REFRESH_TOKEN, host, noMaxAge: true }));
    res.clearCookie(COOKIE_NAME_ID_TOKEN, getAuthCookieOptions({ name: COOKIE_NAME_REFRESH_TOKEN, host, noMaxAge: true }));

    const anonUser = createUserFromData({
      vxid: undefined,
      firstName: undefined,
      lastName: undefined,
      roles: [],
      tags: [],
      status: 'anonymous',
    });

    return this._buildUser(anonUser, req, this.region, res, function (err, user) {
      req.user = user;
      next(err);
    });
  }

  const userObj = createUserFromData(jwt);

  for (const [key, value] of Object.entries(JWT_DELTAX_MAPPING)) {
    renameProperty(userObj, key, value);
  }

  // DeltaX returns auth time as a string
  // userObj.auth_time = userObj.auth_time.toString();

  // Really, userObj.auth_time should be set to stringified jwt.auth_time
  // and userObj.auth_source should be set to jwt.idp_id
  // but in an effort to compress we are temporarily dropping those values during migration period
  // this note should serve as a reminder to switch back to it once OIDC migration is complete.
  userObj.auth_time = userObj.iat.toString();
  userObj.auth_source = 'auth0';

  userObj.status = 'user_logged_in';

  userObj.tags = userObj.tags || [];

  userObj.roles.forEach(role => {
    const tag = ROLE_TAG_MAPPING[role];
    if (tag && !userObj.tags.includes(tag)) userObj.tags.push(tag);
  });

  userObj.jwt = decompressedJwt;

  this._buildUser(userObj, req, this.region, res, function (err, user) {
    req.user = user;
    next(err);
  });
}

EntitlementsService.prototype._refreshTokenRedirect = function (req, res) {
  const state =  getTargetUrlFromReq(req);

  const authUrl = `https://${getHost(req)}/client/auth?state=${encodeURIComponent(state)}`;
  return res.redirect(302, authUrl);
}

/** Return hashed data without secret parameter */
function _hash(algorithm, data) {
  const hash = crypto.createHash(algorithm);
  return hash.update(data).digest('hex').toString();
}

/** Return hashed email for sha1, sha256 and md5 algorithms*/
function _getEmailHashes(user) {
  const { email } = user;
  if (email) {
    return ['sha1', 'sha256', 'md5'].reduce((acc, algorithm) => {
      acc[algorithm] = _hash(algorithm, email);
      return acc;
    }, {});
  }

  return null;
}

/** gets user type info */
function _getType(user, site) {
  if (user.roles) {
    var existing = null;
    for (var index = 0; index < user.roles.length; index++) {
      var match = USER_TYPE_MAP[user.roles[index]];
      if (!match) continue;
      if (match.site && match.site !== site) continue;
      if (existing && match.precedence > existing.precedence) continue;
      if (match.precedence === 0) {
        return match.type;
      }
      existing = match;
    }
    if (existing) return existing.type;
  }
  return user.isLoggedIn() ? 'freeRegister' : 'nonsubscriber';
}

/** formats user experience info */
function _getExp(user) {
  if (user.roles) {
    for (var index = 0; index < user.roles.length; index++) {
      var match = USER_EXP_MAP[user.roles[index]];
      if (match) {
        return match;
      }
    }
  }
  return 'default';
}

const renameProperty = (userObj, oldKey, newKey) => {
  userObj[newKey] = userObj[oldKey];
  delete userObj[oldKey];
}

// Need to provide req.host fallback for tesla apps (e.g. video center)
function getHost(req) {
  return req.hostname || req.host;
}

function getTargetUrlFromReq(req) {
  return `https://${req.headers.host}${req.url}`;
}

/** sets page metadata tags for user experience and user type */
EntitlementsService.prototype._setMeta = function (user) {
  this.metaDataService.setDefaultNameContentMeta('user.type', user.type);
  var meta_tags = user.tags && Array.isArray(user.tags) ? user.tags.sort().join(',') : null;
  if (meta_tags)
    this.metaDataService.setDefaultNameContentMeta('user.tags', meta_tags);

  this.metaDataService.setDefaultNameContentMeta('user.exp', user.experience);
  if (user.vetoFree) {
    this.metaDataService.setDefaultNameContentMeta('r12we4', 'true');
  }
  if (user.company) {
    this.metaDataService.setDefaultNameContentMeta('user.company', user.company || '');
  }
};

module.exports = EntitlementsService;
//for testing:
EntitlementsService._getType = _getType;
EntitlementsService._getExp = _getExp;

EntitlementsService.createUserFromData = createUserFromData;
EntitlementsService.decryptIdentityJwt = decryptIdentityJwt;
EntitlementsService.decryptIdentityJwtWithNonce = decryptIdentityJwtWithNonce;
